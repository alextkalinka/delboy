# Helper functions.
.linear_interpol <- function(x1, y1, x2, y2, x_target){
  m <- (y2-y1)/(x2-x1)
  c <- y2 - m*x2
  y_target <- m*x_target + c
  return(y_target)
}

.calc_fdr <- function(data, msym, hsym, thresh, dir){
  if(dir == "less"){
    data %<>%
      dplyr::filter(!! msym < thresh)
  }else{
    data %<>%
      dplyr::filter(!! msym > thresh)
  }
  data %<>%
    dplyr::summarise(fdr = sum(!! hsym == "False_Positive")/dplyr::n()) %>%
    dplyr::mutate(fdr = ifelse(is.nan(fdr),0,fdr))
  return(unlist(data$fdr, use.names = F))
}

.any_tp <- function(data, msym, hsym, thresh, dir){
  if(dir == "less"){
    data %<>%
      dplyr::filter(!! msym > thresh)
  }else{
    data %<>%
      dplyr::filter(!! msym < thresh)
  }
  data %<>%
    dplyr::summarise(tp = any(!! hsym == "True_Positive"))
  return(unlist(data$tp, use.names = F))
}


#' calc_fdr_threshold
#'
#' Calculates a threshold value for a given metric to achieve a specified FDR.
#'
#' @param data A data frame generated by `delboy::combine_harmonic_mean_pvals`.
#' @param metric_column A character string naming the column in `data` that contains a metric for which we wish to finf a threshold value.
#' @param hit_class_column A character string naming the column in `data` that contains `True_Positive` and `False_Positive` classifications.
#' @param target_fdr Numeric value (0-1) giving the target FDR. Defaults to 0.1.
#'
#' @return A data frame.
#' @importFrom dplyr %>% arrange desc filter summarise n mutate
#' @importFrom rlang sym !!
#' @export
calc_fdr_threshold <- function(data, metric_column, hit_class_column, target_fdr){
  if(!metric_column %in% colnames(data)) stop(paste("can't find",metric_column,"in data"))
  if(!hit_class_column %in% colnames(data)) stop(paste("can't find",hit_class_column,"in data"))
  
  tryCatch({
    metric_sym <- rlang::sym(metric_column)
    hit_sym <- rlang::sym(hit_class_column)
    neg <- ifelse(median(unlist(data[,metric_column]),na.rm=T) < 0,T,F)
    if(neg || grepl("^sd",metric_column)){
      data %<>% dplyr::arrange(dplyr::desc(!! metric_sym))
      dir <- "less"
    }else{
      data %<>% dplyr::arrange(!! metric_sym)
      dir <- "more"
    }
    data_fp <- data %>%
      dplyr::filter(!! hit_sym == "False_Positive")
    if(nrow(data_fp) == 0) stop("no false positives found in data")
    # Loop over FPs and when FDR > 0.1 stop and calculate the metric threshold.
    runn_fdr <- target_fdr+0.1
    any_tp <- FALSE
    i <- 1
    while((runn_fdr > target_fdr || !any_tp) || i > nrow(data_fp)){
      thr <- unlist(data_fp[i, metric_column], use.names = F)
      tfdr <- .calc_fdr(data, metric_sym, hit_sym, thr, dir)
      any_tp <- .any_tp(data, metric_sym, hit_sym, thr, dir)
      cat(tfdr,"\n")
      if(tfdr < target_fdr){
        if(i > 1){
          mb <- unlist(data_fp[i-1, metric_column], use.names = F)
          if(runn_fdr > target_fdr){
            thr <- .linear_interpol(tfdr, mb, runn_fdr, 
                                    unlist(data_fp[i, metric_column], use.names = F), target_fdr)
          }
        }
      }
      runn_fdr <- tfdr
      i <- i+1
    }
  }
  ,
  error = function(e) stop(paste("unable to calculate FDR threshold:",e))
  )
  return(thr)
}
